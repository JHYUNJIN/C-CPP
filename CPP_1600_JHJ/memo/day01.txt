C++
	C++ 은 C언어에 여러 가지 기능을 추가하거나 개선하여 만들어진 C의 상위 버전이다.
	그렇기에 C 코드는 C++ 컴파일러에서도 별다른 수정없이 컴파일된다.
	가장 큰 차이점은 클래스를 지원한다는 것이다. 초기 이름이 C with class 였다.

iostream
	cout 출력 객체와 cin 입력 객체가 정의되어 있다.
	stdio.h 와 같은 역할이라고 보면 된다.

cout
	<<(삽입) 연산자 다음에 출력할 데이터를 적는다.
	데이터의 타입은 출력 객체가 알아서 판단한다.
	C언어처럼 서식을 지정할 필요 없이 편리하게 사용가능하며, 서식이 불일치하여 생기는 문제점도 없다.

	ex) 
		std::cout << "hello" << std::endl; // endl 은 줄바꿈을 의미한다.

cin
	>>(추출) 연산자 다음에 입력한 값을 대입받는 변수를 작성한다.
	마찬가지로 변수의 타입은 구분하지 않아도 된다.

printf, scanf 와 대비되는 장점
	1. 사용방법이 직관적이다.
	2. 데이터의 타입을 자동으로 판별하기 때문에 안전하다.

namespace
	프로그램에서 자주 사용하는 명칭이 있다면 using 키워드를 먼저 선언한 후 생략하는 것이 좋다.
	namespace는 C++의 각종 요소들(변수, 함수, 클래스 등등)을 한 범주에 묶어주기 위한 문법이다.

new, delete
	C의 malloc, free에 대응되는 C++의 메모리 할당 연산자.
	프로그램 실행 중에 메모리를 할당한다는 점에서 용도가 비슷하다.

new
	포인터 = new 타입[(초기값)];
	
	new 다음에 타입을 적으면 sizeof(타입) 만큼의 메모리가 할당되고 할당된 포인터가 리턴된다.
	new가 리턴하는 번지는 같은 타입의 포인터 변수로 대입 받는다.
	할당과 동시에 초기화하고 싶으면 타입 다음 초기값을 적되 초기화를 할 필요가 없으면 생략할 수 있다.

delete
	delete 포인터;

	new 연산자를 통해 할당된 메모리를 해제할 때는 delete 연산자를 사용한다.
	만약 할당만 하고 해제를 하지 않으면 메모리 일부를 사용할 수 없게 되는 Memory Leak 이 발생하므로
	동적 할당한 메모리는 반드시 delete 해야한다.

malloc, free 와 대비되는 장점
	1. malloc, free 는 라이브러리가 제공하는 함수이지만 new, delete는 연산자이다.
	2. malloc 함수는 void* 를 리턴하므로 형변환이 강제되었다. 하지만 new는 해당 타입의 포인터를 리턴한다.
	3. new 연산자로 객체를 할당할 때 생성자가 자동으로 호출된다. delete로 객체를 삭제할 때 소멸자(파괴자)가 자동 호출된다.

























